<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>graph view</title>
</head>
<body style="margin:0;">
    <script type="module">
        
        import * as THREE from '../node_modules/three/build/three.module.js';
        import { GridHelper } from '../node_modules/three/src/helpers/GridHelper.js';
        import { OrbitControls } from '../node_modules/three/examples/jsm/controls/OrbitControls.js';
		import { XYZLoader } from '../node_modules/three/examples/jsm/loaders/XYZLoader.js';
        
        var camera, controls, scene, renderer;
        
        let points;
        let line;
        let drawCount;
        let MAX_POINTS;
        
        let input = document.querySelectorAll("input"),
            rValue = input[0].value,
            gValue = input[1].value,
            bValue = input[2].value;

        input[0].addEventListener("input", function(){
            rValue = this.value;
        });

        input[1].addEventListener("input", function(){
            gValue = this.value;
        });

        input[2].addEventListener("input", function(){
            bValue = this.value;
        });
        
        init();
        animate();
        
        function init(){
            
            
            scene = new THREE.Scene();
            renderer = new THREE.WebGLRenderer();
            renderer.setSize( window.innerWidth, window.innerHeight );
            document.body.appendChild( renderer.domElement );
            
            camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
            camera.position.set( 0, 20, 100 );
            
            controls = new OrbitControls( camera, renderer.domElement );
            
            window.addEventListener( 'resize', onWindowResize, false );
            
            function onWindowResize(){
                
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                
                renderer.setSize( window.innerWidth, window.innerHeight );
                
            }
            
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            
            controls.screenSpacePanning = false;
            
            controls.minDistance = 10;
            controls.maxDistance = 500;
            
            //grid
            var size = 100;
            var divisions = 20;
            var colorCenterLine = 0x333333;
            var colorGrid = 0x222222;
            var gridHelper = new THREE.GridHelper( size, divisions, colorCenterLine, colorGrid );
            scene.add( gridHelper );


            let lineColor = new THREE.Color("rgb(" + rValue + "," + gValue + "," + bValue + ")");
            lineColor.needsUpdate = true;
            
            var lineMaterial = new THREE.LineBasicMaterial( { color: lineColor } );
            lineMaterial.needsUpdate = true;
            
            //loader test
            var geometry = new THREE.BufferGeometry();
            const loaderPoints = new XYZLoader();
            const loaderLine = new XYZLoader();
            
            loaderPoints.load( 'xyz_output/xyz_randomPoints.txt', function ( geometry ) {
                
                geometry.center();
                
                const vertexColors = ( geometry.hasAttribute( 'color' ) === true );
                
                const material = new THREE.PointsMaterial( { size: 0.1, vertexColors: vertexColors } );
                
                points = new THREE.Points( geometry, material );
                scene.add( points );                    
            });
            
            loaderLine.load( 'xyz_output/xyz_randomPoints.txt', function ( geometry ) {
                
                geometry.center();
                
                // draw range
                console.log("geometry count: " + geometry.attributes.position.count)
                MAX_POINTS = geometry.attributes.position.count + 1;
                drawCount = 2; // draw the first 2 points only
                geometry.setDrawRange( 0, drawCount )
                
                //connecting points
                line = new THREE.Line(geometry, lineMaterial);
                scene.add(line);
                
                //total sum distances of line
                line.computeLineDistances();
                let lineSum = line.geometry.getAttribute("lineDistance");
                console.log("line sum: " + lineSum.getX(lineSum.count - 1));
            });
        }

// for further reference on how to animate the line draw visit: https://jsfiddle.net/xvnctbL0/2/

        function animate() {
            
            requestAnimationFrame( animate );

            drawCount = ( drawCount + 1 ) % MAX_POINTS;

	        line.geometry.setDrawRange( 0, drawCount );

            // required if controls.enableDamping or controls.autoRotate are set to true
            controls.update();

            render();

        }
        function render() {

            renderer.render( scene, camera );
        }
    </script>
    <button type="button" onClick="reloadThePage()">Refresh</button>
    <script>
        function reloadThePage(){
            window.location.reload(true);
        }
        
        document.body.style.overflow = 'hidden';
    </script>
    <div class="picker">
        Red <input type="range" min="0" max="255" step="1" id="red" value="64">
        Green <input type="range" min="0" max="255" step="1" id="green" value="0">
        Blue <input type="range" min="0" max="255" step="1" id="blue" value="255">
        <div id="display"></div>
    </div>
</body>
</html>